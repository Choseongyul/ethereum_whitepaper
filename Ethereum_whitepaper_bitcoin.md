<h1> ethereum_whitepaper 정리 </h1>
ethereum white paper 원서 pdf : https://blockchainlab.com/pdf/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf</br>
ethereum white papaer 한글판 : https://ethereum.org/ko/whitepaper/</br>

<h2>history</h2>
<li>합의 알고리즘 : 분산된 시스템 내부에서 하나의 데이터 값에 대해 사람들의 동의를 구하는 과정</br></li>
<li>작업증명(PoW : Proof of work) : 풀기 어려운 문제를 가장 빨리 해결한 사람에게 블록을 생성할 수 있는 권한을 주고 보상으로 코인을 제공하는 방식</br></li>
<br/>
1998년 Wei Dai의 b-money는 탈중화 된 합의 및 계산 퍼즐을 해결함으로써 돈을 만들어내는 아이디어를 처음 제시했지만 탈중앙화를 가능하게 하는지에 대한 설명이 부족했음.</br>
2005년 Hal Finney는 재사용 가능한 작업증명이라는 개념을 소개했음. b-money와 Adam Back의 계산적으로 어려운 해시 캐시 퍼즐을 사용하여 암호화폐에 대한 개념을 만듦. 하지만 신뢰 가능한 컴퓨팅을 백엔드로 사용한다는 점에서 한계를 가졌음.</br>
2009년 사토시 나카모토는 공개키 암호화를 기반으로 하는 소유권 관리와 작업증명으로 알려진 소유자 추적을 위한 합의 알고리즘을 결합하여 최초로 탈중앙화 화폐를 구현함.</br>
<br/>
<h2>상태 전환 시스템으로써의 비트코인</h2>
<img src="https://ethereum.org/content/whitepaper/ethereum-state-transition.png"/>
<li>ledger : 거래를 기록하는 디지털 일지</br></li>
<li>UTXO : 20byte의 주소로 나타내어지는 암호 공개키로 소유자와 액면가 정보가 담긴 거래 정보.</br></li>
<li>민팅 : 블록체인에 등록됨</br></li>
</br>
암호화폐의 ledger는, 현존하는 모든 비트코인의 "상태"와 상태 및 거래를 입력으로 하고 결과를 출력으로 하는 '상태전환 함수'로 구성된 시스템임.</br>
이때 비트코인의 "상태"는 민팅 되었지만 아직 쓰이지 않았음을 의미함. 하나의 거래에서 입력은 현재 UTXO들 중 하나와 그 소유자 주소의 개인 키로부터 생성된 암호 서명을 포함하고, 출력은 "상태"에 추가 될 새로운 UTXO를 포함</br>
<h3>Ex) APPLY(S, TX) -> S'</h3>
<ol>
  <li>1 참조된 UTXO가 기존 상태에 없으면 Error</br></li>
  <li>2 암호서명이 소유자의 UTXO와 일치하지 않으면 Error</br></li>
  <li>모든 입력 UTXO의 액면가 총합이 모든 출력 UTXO의 액면가 총합보다 작으면 Error</br></li>
  <li>모든 입력 UTXO가 제거되고 모든 출력 UTXO가 추가된 새로운 상태 S'를 반환</br></br></li>  
</ol>
1-1은 트랜잭션 발송자가 없는 코인 사용을 방지, 1-2는 타인의 코인을 사용하는 것을 방지, 2는 가치보존 강제를 위함
</br></br>

<h2>채굴</h2>
<img src="https://ethereum.org/content/whitepaper/ethereum-blocks.png" />
비트코인의 탈중앙화 합의 프로세스는 네트워크 상의 노드들이 "블록"이라고 불리는 거래 패키지 생성을 지속적으로 시도함으로써 이루어짐. 각 블록은 타임스탬프, nonce, 이전 블록의 해시 정보, 이전 블록 이후 발생한 모든 거래 목록을 담게 됨.</br>
이러한 블록이 쌓이면서 비트 코인 ledger의 최신 상태를 나타내기 위해 지속적으로 업데이트 되는 <p color="orange">블록체인</p>이 만들어지게 됨.</br>
</br>
<h3>특정 블록 유효성 검증 알고리즘</h3>
<ol>
  <li>해당 블록이 참조하고 있는 앞선 블록이 실제하고 유효함</li>
  <li>타임스탬프는 앞선 블록의 타임스탬프 이후 시간, 차이는 최대 2시간</li>
  <li>해당 블록의 작업증명 유효</li>
  <li>S[0]은 이전 블록의 마지막 상태</li>
  <li>해당 블록이 가진 n개의 거래 리스트를 TX라고 할 때 모든 i(0 ~ n-1)에 대해 S[i+1] = APPLY(S[i], TX[i])를 적용. 어플리케이션이 오류 반환 시 종료하고 false를 return</li>
  <li>5번이 아닌 경우 true를 반환하고, S[n]은 블록 끝에 있는 상태로 등록</li>
</ol>
</br>
상태 정보는 어떠한 형태로도 블록에 저장되지 않고, 각 검증 노드에 의해 기억되어야 하고, 모든 블록에 대해 제네시스 상태(발생 상태)에서 시작해 모든 블록의 모든 거래를 순차적으로 적용 해야만 안전하게 계산 가능.</br>
또한, 채굴자가 거래를 블록에 추가하는 순서가 중요하다. 만약 블록에 거래 A, B가 있을 때 B가 A로 인해 생성된 UTXO를 사용한다면, 블록은 A가 B보다 먼저 실행되는 경우만 유효. 역은 유효하지 않음.</br>
위에서 설명한 유효성 조건은 "작업증명(PoW)"에 대한 요구인데, 256bit으로 처리되는 모든 이중 SHA256 해시 값이 동적으로 조정되는 값보다 반드시 작아야 한다는 것이다. SHA256은 예측 불가능한 랜덤 함수이기 때문에, 유효한 블록 생성 방법은 nonce값을 증가시키면서 해시 값이 일치하는지 단순 반복하는 것밖에 없다.</br>
이렇게 수학적으로 복잡하게 만드는 이유는 블록체인 네트워크를 점령하는 시빌공격(sybil attack)을 방지하기 위함이다.</br></br>
블록을 생성한 채굴자는 신규 생성된 25BTC를 받게 되고, 만약 전체 액면가를 따졌을 때 입력이 출력보다 많다면, 그 차액 또한 채굴자에게 "거래 수수료"로 제공하게 된다. 예를 들어 한 거래에서 입력 값이 1BTC이고 출력이 0.9BTC라면 남은 0.1BTC는 채굴자가 받게 된다. 즉, 채굴자는 고정된 25BTC + 거래수수료를 보상으로 받게 되는 것.</br>
위 채굴 목적을 이해하기 위해 악의적인 해커가 거래의 순서를 타겟으로 블록체인 네트워크를 공격하는 상황을 보자.</br>
<ol>
  <li>한 상점에서 100BTC울 결제한다.</li>
  <li>해당 물건을 받는다.</li>
  <li>기존 100BTC을 자기 자신에게 이체하는 거래를 생성한다.</li>
  <li>세번째 단계가 물건을 구매한 행위보다 먼저 일어났다고 네트워크가 믿도록 만듦</li>
</ol>
1단계 이후 채굴자들은 거래를 블록에 포함시키고, 블록 숫자가 270000이라고 하자. 약 1시간 뒤에 다섯 개의 블록이 생성 되었다고 하자. 이후 해커는 270000 블록을 fork를 이용하여 새롭게 생성함으로써 기존 체인과 분리되게 된다. fork를 생성하는 과정에서 해시값이 달라지므로 기존 체인에서 분리될 수 있다.</br>
해커는 270000 블록에서 작업을 하여 기존 체인의 길이를 따라잡고 가장 길어지도록 한다. 이렇게 더 길어진 해커의 체인을 정상적인 네트워크에 전파함으로써 네트워크를 교란시킨다. 이 과정에서 상점에서 결제한 내역이 무효화 되고 자기 자신에게 이체하는 거래가 유효하게 처리됨으로써 정상적인 네트워크에 피해를 입히게 된다. 이 방식이 "51% 공격"이다.</br></br>

<h2>머클트리</h2>
<img src="https://ethereum.org/content/whitepaper/spv-bitcoin.png"/>
<h4>왼쪽 그림 : 가지 한 개의 검증에는 머클 트리의 일부 노드만 있으면 충분함<br/></h4>
<h4>오른쪽 그림 : 머클 트리의 어느 일부분이라도 바뀌면, 체인 위쪽 어느 한 곳에서 불일치가 생길 수 밖에 없음<br/></h4>
블록의 해시는 약 200byte 크기의 정보를 담은 블록 헤더의 해시로 구성요소는 다음과 같다 : <br/>
<li>타임스탬프 : 블록 생성 시간</li>
<li>nonce</li>
<li>이전 블록의 해시</li>
<li>머클 트리의 루트 해시</li></br>
머클트리는 이진트리의 일종으로, 데이터를 담고 있는 리프노드, 2개의 자식노드의 해시로 만들어지는 중간노드, 2개의 자식 노드의 해시에서 형성되어 최상단에 존재하는 루트 노드로 이루어져 있다.</br>
머클트리의 목적은 일부 정보만 제공되어도 충분히 데이터의 신뢰성을 검증할 수 있게 하는데 있다. 이것이 가능한 이유는 각 노드들에 있는 해시값들이 트리의 위쪽 방향을 가리키고 있기 때문이다.</br>
이 자료구조가 필요한 이유는 시간이 지남에 따라 블록체인 네트워크의 크기는 증가하고 있어서 미래에는 일부 기업 단위, 일부 사람들만 참여할 수 있게 될 것이다.</br>
따라서 일반 사용자들은 블록 헤더만으로 작업증명을 진행하고, 이후 특정 거래와만 관련된 일부 "가지" 데이터만 받아서 검증을 진행함으로써 일반 사용자도 블록체인 네트워크에 참여할 수 있도록 한다. 이 방식은 간략화 된 결제 검증이라 불리는 SPV 프로토콜이다.
</br></br>

<h2>다양한 블록체인 응용 예시</h2>
블록체인 기술을 다른 분야에 적용하는 시도는 2005년 Nick Szabo에 의해 제안 되었으나 제시 된 아이디어에 쓰여야하는 효과적인 데이터베이스 복제 시스템이 없어서 실현되지 못했다.</br>
2009년 비트코인의 탈중앙화 된 합의 메커니즘이 발표된 이후 네임코인, 컬러코인, 메타코인과 같은 다양한 응용 프로그램들이 나타나기 시작했다.</br>
위에서 등장한 응용 프로그램을 보면 일반적으로 합의 프로토콜을 만드는 방법은 크게 두 가지라고 할 수 있는데, 독자적인 네트워크를 만들거나, 비트코인 프로토콜 위에 프로토콜을 세우는 것이다.</br>
독자적인 네트워크를 만드는 것은 블록체인, 네트워크, 상태전환 코드 등 모두 새로 구축하면서 테스트하는 부트스트랩이 필요하기 때문에 어렵다. 그리고 대다수가 자신들만으로는 참여자가 적어 블록체인을 보증하는 데 어려움을 겪는다.</br>
비트코인은 체인의 길이가 신뢰도로 이어지기 때문에 한 거래가 있을 때 앞선 거래들을 백트랙킹 할 수 있다면, 그 거래들은 정상적으로 포함 되었다고 볼 수 있다(SPV 방식)</br>
하지만 비트코인 블록체인 위에 만들어진 프로토콜들은 자신들의 프로토콜 상에서는 유효하지 않은 거래를 해당 블록체인이 포함하지 않도록 강제할 수 없다는 단점이 있다. 특정 거래의 유효성을 검증하기 위해서는 해당 거래에서 처음부터 끝까지 모두 확인해야해서 암호화폐의 목적인 탈중앙화 측면에서 최선은 아니다.</br>
<h3>비트코인 블록체인 위에 만들어진 프로토콜에서 유효하지 않은 거래를 강제할 수 없는 이유</h3>
<li>분산화 및 비허가성 : 비트코인 블록체인은 분산화 되어 있고, 비허가성(누구나 참여 할 수 있는)네트워크이므로, 네트워크 참여자 간 광범위한 합의가 필요함.</li>
<li>합의 규칙 : 비트코인의 핵심 프로토콜에 의해 정의 된 합의 규칙에 따라 거래 유효성이 결정되고, 상위 레이어 프로토콜의 규칙은 이에 우선하지 않음.</li>
<li>블록체인 레이어 한계 : 상위 레이어 프로토콜이 비트코인의 기본 레이어에 직접적인 영향을 미칠 수 없음.</li>
<li>보안 및 신뢰성 문제 : 상위 레이어가 기본 비트코인 레이어를 제어할 수 있다면 전반적인 비트코인 블록체인 네트워크를 취약하게 만들 수 있음.</li>
</br></br>

<h2>스크립팅</h2>
