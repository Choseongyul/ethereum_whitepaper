<h1>Ethereum white paper 정리</h1>

<h2>변형 GHOST 구현</h2>
GHOST 프로토콜이란 Greedy Heaviest Object subTree의 약자로 가장 큰 무게를 가진(블록 개수가 많은) subtree를 선택하는 알고리즘이다.</br>
짧은 승인 소요 시간을 지닌 블록체인 프로토콜의 공통적 단점이었던 낮은 보안성과 높은 부실 블록률을 해결하기 위해 고안되었다.</br>
이때 부실 블록이란 두 개의 브록이 동시에 승인 되었을 때 메인체인으로 연결되지 못 해 따로 떨어져 존재하는 블록이다.</br>
예를 들어 채굴자 A가 블록을 채굴했는데 이를 B에게 전달하는 동안 B도 블록을 채굴했다고 한다면, B가 채굴한 블록은 낭비된다.</br>
또한 채굴자 A가 채굴자 B보다 더 큰 해시 파워를 가진다면 블록체인 네트워크의 전체 채굴 프로세스는 A에게 지배 될 가능성이 높아 이는 중앙화 문제로 이어진다.</br>
이러한 네트워크 보안에 있어 첫번째 문제를 GHOST는 어떤 체인이 가장 긴지 결정할때 부실 블록도 고려하여 비교하여 문제를 해결한다. 즉, 부실블록도 체인 길이 식에 포함하여 가장 긴 PoW를 결정한다.</br>
또한 두번째 문제는 부실블록에도 채굴 보상을 제공하는 방법으로 해결한다. 하나의 부실 블록은 기본 보상의 87.5%를, 해당 부실 블록의 앞선 조카 블록은 나머지 12.5%를 받도록 한다. 다만 거래 수수료는 삼촌 블록에 제공하지 않는다.</br>
이더리움은 7세대로 이루어진 간소화 된 GHOST를 사용한다. 방식은 다음과 같다 : </br>
<li>하나의 블록은 반드시 1개의 부모 블록을 가져야 함</li>
<li>B라는 블록이 있을 때 블록의 삼촌 블록은 반드시 아래와 같은 특성을 만족해야 한다.</li>
<ul>
  <li>블록 B의 k세대 조상의 직계 자식이어야 함 (단, 2<=k<=7)</li>
  <li>B의 조상이 아니다</li>
  <li>삼촌 블록은 반드시 유효한 블록 헤더여야 하지만, 앞서 검증 받을 필요 없음</li>
  <li>삼촌 블록은 이전 블록들에 포함된 모든 삼촌 블록 및 같은 블록에 포함된 모든 다른 삼촌 블록과 달라야함.</li>
</ul>
<li>블록 B에 있는 모든 삼촌 블록 U에 대하여, 블록 B의 채굴자는 코인베이스 보상에 추가로 3.125%를 얻고, 블록 U의 채굴자는 표준 코인베이스 보상의 93.75%를 얻는다.</li>
이더리움이 GHOST의 제한 버전을 사용하는 이유는 무제한적인 GHOST는 특정 블록의 유효한 삼촌 블록을 정하기 위한 계산을 지나치게 복잡하게 만든다. 두번째로 제한없는 GHOST방식은 채굴자들이 메인체인에서 채굴을 할 이유가 사라진다.</br>
</br>
    
<h2>수수료</h2>
블록체인에서 거래 남용을 막기 위해 일반적으로 거래 수수료와 관련된 규제 매커니즘이 필요하다. 비트코인에서 사용되는 기본 접근법은 순수하게 자발적인 수수료가 있고, 채굴자가 동적인 최소값을 설정하는 데 의존한다.</br>
이러한 접근법은 가격이 결정되는 방식이 시장 기반 방식이라는 점에서 비트코인 커뮤니티에서 매우 우호적이다. 하지만 거리가 처리되는 전체 과정에는 시장원리가 적용되지 않는다.</br>
거래는 한명의 채굴자가 블록으로 포함한 이후에 네트워크 상의 모든 노드로 퍼지며 연이어 처리되는 방식이기 때문에 거래 처리에 소요되는 비용의 대부분은 나머지 네트워크에 의해 발생된다고 봐야한다.</br>
이는 공유지의 비극 문제를 발생 시킬 수 있는데 이러한 결점은 부정확한 가정이 적용되면 마법처럼 상쇄될 수 있다. 이때 가정은 다음과 같다 : <br/>
<ol>
  <li>거래를 처리하는데 k번의 연산이 소요되고, 발신자가 정한 R값이 있을 때 채굴자에게 kR만큼의 보상이 주어진다는 것을 채굴자가 사전에 볼 수 있다.</li>
  <li>운영은 모든 노드에 대해 C의 처리비용을 갖고 있다.</li>
  <li>총 N개의 채굴 노드가 있고, 채굴능력은 동일하다.</li>
  <li>모든 노드가 채굴에 참여하고 있다.</li>
</ol>
당연하게도 채굴자는 보상이 채굴비용보다 클 때만 거래를 진행할 것이다. 위 가정에서 블록 채굴확률은 1/N이고, 예상 보상은 KR/N임을 알 수 있다. 또한 채굴비용은 KC이다.</br>
따라서 KR/N > KC 또는 R > NC인 경우에만 거래를 포함할 것이다. 발신자가 설정한 R은 연산당 수수료 값으로 해당 거래에 의해 만들어지는 최소한의 보상이라고 볼 수 있고, NC는 연산당 전체 네트워크가 소비해야 하는 비용이라고 볼 수 있다.</br>
결론적으로 채굴자는 전체 공공의 이익이 비용보다 큰 거래만 포함시키는 인센티브를 갖게 된다. 하지만 실제로는 위 가정들과 몇 가지 차이점이 있다 : </br>
<ol>
  <li>블록이 다른 노드로 퍼질 때 검증 시간이 소요되는데, 이 시간동안 이 블록이 부실 블록이 될 가능성을 높여 채굴자는 더 많은 비용을 지불하게 된다.</li>
  <li>채굴에 참여하지 않는 노드도 있다</li>
  <li>채굴력은 불평등 할 수도 있다</li>
  <li>네트워크에 악의적인 행위자들이 존재하고, 이들은 자신들의 비용에 비해 전체 네트워크 검증 비용이 훨씬 높게 나오는 계약을 생성할 수 있다.</li>
</ol>
1은 채굴자들이 블록에 포함하는 거래 수를 줄이도록 유도하고, 2는 NC값을 증가시킨다. 따라서 이 두 효과는 부분적으로 서로 상쇄한다. 3번과 4번은 주요한 문제인데 이를 해결하기 위해 단순하게 상한을 도입했다.</br>
비트코인에 데이터가 많이 담긴 블록을 만들지 않도록 유도하는 요소는 크기가 큰 블록은 네트워크로 퍼져 나가는데 시간이 오래 걸려서 부실 블록이 될 가능성이 높아진다는 점이다. </br>
이더리움에서는 지연이 일으키는 부정적인 효과가 GHOST프로토콜 덕분에 덜하다. 즉, 블록에 한도를 부여하는 방식이 더 안정적인 기준선을 제공하는 것이다.</br>
</br>

<h2>연산과 튜링-완전</h2>
EVM은 튜링 완전하여 어떤 연산이든 코드로 작성 가능하다. EVM코드는 두가지 방식으로 루프를 지원하는데, 첫번째 JUMP 명령어는 프로그램이 코드의 이전 부분으로 돌아갈 수 있도록 하고, JUMPI 명령어는 조건부로 되돌아갈 수 있도록한다.</br>
두번째 계약은 다른 계약을 실행할 수 있어서 필요 시 재귀방식의 루프를 만들 수 있다. 하지만 이는 악의적인 사용자가 채굴자와 전체 노드를 무한 루프에 빠지게하여 불능으로 만들 수 있다는 문제를 수반한다. 이 문제는 정지문제 현상때문인데, 프로그램이 언제 멈출지 미리 알 수 없는 현상을 말한다.<br/>
거래에 쓰이는 연산 수에 대한 최대값을 설정함으로써 해결할 수 있고, 더 많은 연산이 쓰일 시 거래는 되돌려지는 반면 수수료는 그대로 지불된다.</br>
</br>

<h2>통화와 발행</h2>
이더리움 네트워크는 자체 내장 통화인 Eth를 포함하고, Eth는 다양한 형태의 자산들 간 효율적인 거래가 이루어지기 위한 유동성을 제공하고, 거래 수수료에 대한 두 가지 역할을 하고 있다.</br>
<h3>장기 공급 증가율</h3>
<img src="https://ethereum.org/_next/image/?url=%2Fcontent%2Fwhitepaper%2Fethereum-inflation.png&w=1920&q=75"/>
연속적인 통화 발행에도 공급 증가율은 0으로 수렴한다.</br>
이러한 모델을 택한 첫번째 이유는 적립금의 존재와 그 규모이고, 두번째는 비트코인에 존재하는 한계 있는 공급과 다르게, 지속적으로 증가하는 연속 공급의 존재이다.</br>
만약 적립금 제도가 없고, 연속 발행이 0.217X로 감소하여 동일한 인플레이션율을 제공한다면, 전체 ether 수는 16.5%로 감소하고 각 단위의 가치는 19.8% 증가하게 된다.</br>
그리고 균일하게 각 단위가 이전과 같은 가치를 갖기 위해 19.8% 더 많은 양의 ether가 판매된다. 조직은 또한 1.198배 BTC를 갖게 되는데, 이 상황은 결국 적립금 제도를 두었을 때와 동일한 양의 적립금을 설정했다고 볼 수 있는데, 단위가 BTC이므로 이더 가치에 도움이 되는 유형의 적립금은 아니다.</br>
</br>

<h2>채굴 중앙 집중화</h2>
비트코인 채굴 알고리즘은 한 노드가 특정 타겟 숫자보다 작은 해시 값을 얻을 때까지 채굴자가 조금씩 다른 블록 헤더들의 SHA256 해시값을 계속해서 연산하는 방식으로 이루어진다. 그러나 이러한 채굴 알고리즘은 다음 두가지 형태의 중앙집중화에 취약하다 : </br>
<ol>
  <li>채굴 생태계는 현재 비트코인 채굴만을 위해 설계되어 ASIC에 의해 지배되고 있어서 탈중앙화, 평등주의적이지 않고 참여하기 위해서 많은 자본을 요구하는 분야가 되었다.</li>
  <li>대부분의 채굴자들은 직접 블록검증을 하지 않고, 중앙집중화 된 채굴 풀에 소속되어 블록 헤더를 제공한다.</li>
</ol>
위 문제는 2024년 3월 14일 기준 3곳의 채굴 풀이 비트코인 네트워크 전체 처리 능력의 50%를 차지하고 있다는 점이다.</br>
</br>
<h2>확장성</h2>
이더리움에서 확장성은 종종 문제점으로 거론되는데, 비트코인과 같이 이더리움도 모든 거래가 네트워크 상의 모든 노드에 의해 처리 되어야 한다.</br>
이더리움은 상태만 저장하면 되므로 비트코인보다 더 나을 수 있지만, 다양한 어플리케이션까지 블록체인에서 처리돼야 하기 때문에 더 안좋을 수 있다.</br>
블록체인 사이즈가 커지면 중앙집중화 리스크가 생긴다. 사이즈가 너무 커질 경우 일반 사용자들은 SPV 노드를 사용할거고, 일부 사업체만 풀 노드를 돌릴 수 있게 될 것이다.</br>
이렇게 되면 풀노드를 돌리는 일부가 악의적으로 이익을 편취할 수 있게 되는데, 일반 사용자들이 사용하는 라이트 노드로 이 행위를 즉시 탐지할 수 없다. 또한 정직한 일부가 커뮤니티에 사기정보를 공유하고 일반 사용자가 해당 거래를 블랙 리스트화 하려고 해도, 이는 성공적으로 51% 공격을 막으려고 하는 것과 같이 비현실적이다.</br>
이더리움은 이러한 문제에 대처하기 위해 두가지 전략을 추가로 구사할 것이다 : </br>
<ol>
  <li>최소한 모든 채굴자는 풀 노드가 되면서, 풀 노드 수의 하한선 구성</li>
  <li>각 거래가 처리된 이후 블록체인에 중간 상태의 트리 루트를 포함</li>
</ol>
정직한 검증 노드가 단 하나라도 존재한다면, 검증 프로토콜을 통해 중앙집중화 문제가 해소될 수 있다. 만약 유효하지 않은 블록이 생성됐다면, 해당 블록은 잘못된 형식이 되거나 상태 S[n]이 올바르지 않다. S[0]은 옳다고 알려져 있으므로, 상태 S[i - 1]은 참값이지만 거짓인 첫번째 상태 S[i]가 존재할 것이다.</br>
검증 노드는 해당 인덱스를 비유효성 증명을 처리하기 위한 패트리시아 트리의 일부와 함께 제시할 것이다. 더욱 정교화 된 공격에는 불완전한 블록을 생성하는 악의적인 채굴자들이 포함되므로, 블록 유효성 판단을 위한 정보가 존재하지 않는다.</br>
이에 대한 해결책으로 챌린지-응답 프로토콜이 있다. 검증 노드들은 타겟 거래 인덱스 값들로 챌린지를 하고, 라이트 노드들은 다른 채굴자 혹은 검증자들이 유효성 증거로 패트리시아 트리 일부를 제공하기 전까지 해당 블록을 신뢰하지 않는 방식이다.
