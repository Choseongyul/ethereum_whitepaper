<h1>Ethereum white paper 정리</h1>
<h2>이더리움</h2>
이더리움은 비트코인과 달리 튜링 완전 프로그래밍 언어가 내장된 블록체인이라는 추상화 기반 레이어를 만듦으로써 누구든지 smart contract와 탈중앙화 된 어플리케이션을 만들고, 고유의 소유권 규칙, 거래 형태, 상태 전환 함수를 적용할 수 있도록 했다.</br></br>

<h2>이더리움 계정</h2>
이더리움에서 상태는 "계정"이라고 불리는 객체들로 이루어지고, 각 계정은 20byte 크기의 주소 그리고 계정들 간에 이루어지는 가치 및 정보의 직접적인 거래를 뜻하는 상태 전환을 담고 있다.</br>
이더리움 계정은 4개의 프로퍼티를 가진다 : </br>
<li>논스 : 각 거래가 한번만 처리되도록 하기 위한 카운터</li>
<li>잔액 : 계정의 현재 Eth 잔액</li>
<li>contract code</li>
<li>해당 계정의 저장소</li>
이때 Eth는 이더리움 내부 crypto-gas이고, 거래 수수료를 지불하기 위해 쓰인다. 그리고 일반적으로 계정은 개인 키로 관리되는 외부에서 소유한 계정과 contract code로 관리되는 계약 계정 두 가지 형태가 있다.</br>
외부 계정은 contract code가 없으며, 거래를 생성하고 서명함으로써 메시지를 보낼 수 있다. </br> 계약 계정은 메시지를 받을 때마다 자신의 코드를 실행하여 내부 저장 공간의 데이터를 읽거나 쓰고, 새로운 계약을 생성하는 다양한 활동이 가능하다.
</br>
</br>

<h2>메시지와 거래</h2>
이더리움에서 거래란 외부에서 소유한 계정으로부터 보내진 메시지를 저장하는 서명된 데이터 패키지를 의미한다.</br>
거래에는 다음과 같은 내용들이 포함된다 : </br>
<li>메시지 수신자</li>
<li>발신자 서명</li>
<li>발신자 >> 수신자 Eth 총액</li>
<li>추가 데이터 필드 : 필요시 데이터에 접근하기 위한 계약을 사용하는 명령 코드</li>
<li>START GAS : 거래 실행 시 가능한 최대 연산 횟수</li>
<li>GAS PRICE : 각 연산마다 발신자가 부담하는 수수료</li>
수수료 시스템의 목적은 악의적인 해커에 의해 네트워크가 망가지는 것을 막기 위함인데, 소비하는 연산, 대역폭 및 저장공간 등 모든 리소스의 양에 비례하여 비용을 지불하도록 한다.</br>
즉, 더 많은 리소스를 쓰는 경우 그 증가한 양에 비례하여 더 많은 가스 수수료를 내도록 하는 것이다.
</br>
</br>
  
<h2>메시지</h2>
하나의 계약이 다른 계약에 메시지를 보낼 수 있음. 이더리움 실행 환경에서만 존재하는 가상의 목적물이고, 다음 내용을 포함한다. : </br>
<li>발신자</li>
<li>수신자</li>
<li>Eth 총액</li>
<li>추가 데이터 필드</li>
<li>START GAS</li>
본질적으로 거래와 같지만 <font weight="bord">계약에 의해</font> 만들어진다는 점이 다르다.</br>
메시지는 계약이 CALL 명령어를 실행할 때 생성된다. 따라서 거래와 마찬가지로 다른 계약들과 관계를 맺는다.</br>
거래 혹은 계약에 할당된 가스 허용량은 하위 거래 및 실행을 모두 고려하여 적용된다. 예를들어 A가 B에게 거래를 보낼 때 가스 허용량으로 1,000gas를 설정했고 B가 C에게 메시지를 보내기까지 600gas를 사용하고, C의 내부적인 실행이 반환 전 300gas를 사용했다면 B는 100gas를 더 사용할 수 있다.
</br>
</br>

<h2>이더리움의 상태전환 함수</h2>
<img src="https://ethereum.org/content/whitepaper/ether-state-transition.png"/>
이더리움 상태 전환 함수, APPLY(S, TX) -> S'는 다음과 같이 정의된다. : </br>
<ol>
  <li>거래 구성이 올바른지, 서명이 유효한지, 논스 값이 발신자 논스 값과 일치하는지 확인</li>
  <li>STARTGAS * GASPRICE 값을 수수료로, 서명으로 발신자 주소 확인. 발신자 계정 잔고를 수수료만큼 줄이고, 논스 값 1 증가.</li>
  <li>GAS = STARTGAS를 초기화하고 트랜잭션 바이트에 대해 지불하기 위해 바이트당 일정량의 gas 제거</li>
  <li>수신자 계정에 거래 값을 전송. 만약 수신자 계정이 계약 계정이라면 해당 계약 코드에 대해 실행 완료될 때까지 또는 gas를 모두 사용할 때까지 실행.</li>
  <li>발신자 잔고가  부족하거나 가스 부족 등 코드 실행이 중단 된다면 수수료를 제외한 모든 상태전환을 롤백하고, 수수료는 채굴자의 계정에 추가</li>
</ol>
위 그림에 Transaction의 거래를 전송한다고 가정했을 때 함수의 프로세스는 다음과 같다 :
<ol>
  <li>거래 유효성 판단</li>
  <li>발신자가 2000 * 0.0001 = 2Eth를 소유하고 있는지 확인. (0.0001Eth는 Gas price, 2Eth 수수료)</li>
  <li>gas = 2,000으로 초기화. byte 당 수수료가 5gas고, 170byte 길이의 거래라면 850gas이 빠지고 1150gas가 남음</li>
  <li>10Eth를 발신자 잔고에서 빼고 계약 계정에 추가</li>
  <li>코드 실행. 이때 187gas가 사용된다고 가정하면 남은 gas는 963gas</li>
  <li>963gas * 0.001Eth = 0.963 Eth를 발신자 계정 추가 후 최종 상태 반환</li>
</ol>
거래가 다른 계약을 수반하지 않으면 전체 거래 수수료는 GASPRICE * 거래 길이, 거래와 함계 전송된 데이터와는 무관. 그리고 롤백을 하는 경우 메시지와 거래는 동일 방식으로 이루어짐.</br>
</br>
<h2>코드 실행</h2>
일반적으로 코드 실행이란 현재의 프로그램 카운터에서 연산을 지속적으로 실행하는 무한 루프를 의미하고, 코드가 끝나거나 stop 또는 return이 될때까지 카운터를 1씩 증가시킴.</br>
이 작업은 데이터를 저장하기 위해 3가지 유형의 공간에 접근한다 : </br>
<li>stack : 후입선출 컨테이너</li>
<li>memory : 무한 확장 가능한 바이트 배열</li>
<li>저장공간 : 일시적인 저장소가 아닌 장기간 유지되는 저장소</li>
코드는 각 값들, 메시지 데이터, 블록 헤더 데이터에 접근 가능하고, 필요시 데이터의 배열을 출력으로써 return 가능.</br>
EVM이 실행 중일 때 연산 상태는 튜플(block_state, transaction, message, code, memory, stack, pc, gas)로 정의함.</br>
이 때 block_state는 모든 계정을 포함하는 global 상태이고 잔고 및 저장공간이 포함됨. 실행이 시작될 때 현재 명령어는 code의 pc번째 byte에서 불러와지고, 각 명령어는 튜플에 어떤 영향을 미치는지에 대한 고유한 정의가 있음.</br>
</br>
<h2>블록체인과 채굴</h2>
<img src="https://ethereum.org/content/whitepaper/ethereum-apply-block-diagram.png"/>
이더리움 블록체인과 비트코인의 블록체인 구조는 유사하지만 큰 차이점은 이더리움 블록은 "가장 최근의 상태", 블록 번호와 난이도 또한 블록에 저장된다.</br>
이더리움의 기본적인 블록 검증 알고리즘은 다음과 같다 : </br>
<ol>
  <li>참조된 이전 블록의 존재와 유효성 확인</li>
  <li>해당 블록의 타임스탬프가 앞선 블록보다 나중이고, 이전 블록 기준 15분 이내인지 확인</li>
  <li>블록 번호, 난이도, 거래루트, 삼촌루트, gas최대값이 유효한지 확인</li>
  <li>해당 블록의 작업증명 유효성 확인</li>
  <li>S[0]를 앞선 블록의 마지막에 있는 상태라고 하자</li>
  <li>TX는 블록의 거래 리스트, n은 거래라고 하자. 위에서 살펴본 APPLY에 대해 어느 어플리케이션이라도 오류를 반환하거나 gas최대값을 초과하면 error return</li>
  <li>S_FINAL을 S[n]. 채굴자에게 지불되는 블록 보상을 추가</li>
  <li>S_FINAL의 머클트리 root의 상태가 블록 헤더에 저장된 최종 상태와 일치하는지 확인</li>
</ol>
각 블록에 전체 상태를 저장함. 이 상태는 트리 구조로 저장되고, 블록이 생성될 때마다 트리의 작은 일부분만 바뀌면 되서 인접한 블록들은 트리가 일치하게 되고 데이터가 저장되고 나면 이후 포인터(서브트리 해시)를 사용하여 참조될 수 있다.</br>
이는 머클 패트리시아 트리로 불리는 트리구조가 이를 위해 사용되는데, 노드의 삽입, 수정, 삭제를 효율적으로 하기 위해 머클트리를 변형 시킨 것이다.</br>
</br>
<h3>머클 패트리시아 트리</h3>
<img src="https://velog.velcdn.com/images/choyeah/post/901cf7f4-907b-4534-8374-1e4fe178652b/image.png"/>
머클 패트리시아 트리를 알기 이전 트라이(trie)라는 것을 알 필요가 있다. trie는 문자열 검색을 빠르게 하기 위해 한 문자씩 트리 구조로 저장하는 자료구조이다. 여러 문자열을 한번에 저장할 수 있어서 효율적이고 검색 속도가 빠르다.</br>
패트리시아 트라이는 일반적인 트라이와 달리 접두사를 문자열로 묶어 하나의 노드에 저장하는 방식으로, 여러 단어가 있을 때 공통 접두사를 노드에 저장하여 공간 효율성과 메모리 효율성이 좋다.</br>
머클 트리와 퍄트리시아 트라이를 합친게 머클 페트리시아 트리다. 머클 패트리시아 트리는 머클 트리와 마찬가지로 해시값을 리프노드에 저장하고 루트노드에는 해싱된 값을 다시 해싱하여 저장한다.</br>
이때 각 노드는 접두사를 이용해 구분하고 트리는 레벨DB에 저장한다. 위 그림에서 <font weight="bold">Extension Node</font>는 트라이의 길이를 압축하는 데 사용한다. 이 노드는 공통 접두사를 가지는 경로를 나타내고, 키의 일부를 나타내는 공통 접두사를 저장한다.</br>
키값이 길고, 중복되는 경로가 많을 때 이 중복을 제거하고, 트리의 특정 부분으로 빠르게 이동하기 위해 공통된 경로를 압축하여 저장하여 트리의 깊이를 줄여 검색 시간을 단축할 수 있음.</br>
<font weight="bold">Branch Node</font>는 트리 내에서 분기점을 나타낸다. 이 노드는 16진수 한 자리에 해당하는 16개의 포인터를 가질 수 있고, 트리의 각 분기를 나타낸다.</br>
트리의 특정 부분으로 탐색할 때 어느 방향으로 탐색을 계속할지 결정하는 데 사용된다.
